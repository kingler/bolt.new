---
component: chat_components
description: Contains components for the chat interface in the application
main-technologies:
  - TypeScript
  - React
  - Framer Motion
  - Shiki
  - React Markdown
conventions:
  - Use memoization for performance optimization
  - Use Framer Motion for animations
  - Use Shiki for syntax highlighting
  - Use React Markdown for rendering markdown content
---

# Chat Components

This directory contains components for the chat interface in the application. These components define the structure and behavior of various elements within the chat interface, enabling a rich and interactive user experience.

## Structure

- `Artifact.tsx`: Component for displaying artifacts related to chat messages
- `AssistantMessage.tsx`: Component for rendering messages from the assistant
- `BaseChat.tsx`: Base component for the chat interface
- `Chat.client.tsx`: Main chat component that integrates various sub-components
- `CodeBlock.tsx`: Component for rendering code blocks with syntax highlighting
- `Markdown.tsx`: Component for rendering markdown content
- `Messages.client.tsx`: Component for displaying a list of chat messages
- `SendButton.client.tsx`: Component for the send button in the chat interface
- `UserMessage.tsx`: Component for rendering messages from the user

## Key Responsibilities

1. Defining the structure and behavior of chat interface components
2. Ensuring smooth animations and transitions within the chat interface
3. Providing syntax highlighting for code blocks
4. Rendering markdown content within chat messages
5. Managing the state and interactions of chat messages

## Development Guidelines

- Use memoization (React.memo) for performance optimization
- Utilize Framer Motion for animations and transitions
- Implement syntax highlighting using Shiki
- Render markdown content using React Markdown
- Use type hints and docstrings for better code readability

## Component Implementation

### Artifact.tsx

@Artifact.tsx This component is responsible for displaying artifacts related to chat messages. It uses Framer Motion for animations and integrates with the workbench store to manage the state of artifacts. The component retrieves artifacts from the store, computes actions from the artifact's runner, and toggles the visibility of actions based on user interaction and the presence of actions.

#### How It Works

1. **Initialization**:
   - The `Artifact` component is initialized with a `messageId` prop, which is used to identify and retrieve the corresponding artifact from the store.

2. **State Management**:
   - The component uses the `useState` hook to manage the visibility of actions (`showActions`) and a `useRef` hook to track if the user has toggled the actions (`userToggledActions`).

3. **Retrieving Artifacts**:
   - The `useStore` hook is used to retrieve artifacts from the `workbenchStore`. The specific artifact corresponding to the `messageId` is extracted from the store.

4. **Computing Actions**:
   - The `computed` function from `nanostores` is used to compute the actions from the artifact's runner. These actions are then stored in the component's state.

5. **Toggling Actions**:
   - The `toggleActions` function is defined to toggle the visibility of actions. It updates the `showActions` state and sets `userToggledActions` to `true`.

6. **Effect Hook**:
   - The `useEffect` hook is used to automatically show actions if there are any and the user hasn't toggled them manually. This ensures that actions are visible by default if they exist.

7. **Rendering**:
   - The component renders a button that toggles the visibility of the workbench. It also conditionally renders a button to toggle actions if there are any actions present.
   - The `AnimatePresence` and `motion` components from Framer Motion are used to animate the visibility of actions.
   - If `showActions` is `true` and there are actions, the `ActionList` component is rendered to display the list of actions.

By following these steps, the `Artifact` component ensures that artifacts related to chat messages are displayed with smooth animations and that actions can be toggled based on user interaction and their presence.

### AssistantMessage.tsx

@AssistantMessage.tsx This component is responsible for rendering messages from the assistant within the chat interface. It ensures that the assistant's messages are displayed correctly with proper formatting and styling by utilizing the Markdown component to render the content as HTML.

#### How It Works

1. **Component Initialization**:
   - The `AssistantMessage` component is a functional component that takes `content` as a prop. This prop contains the message content to be displayed.

2. **Memoization**:
   - The component is wrapped with `React.memo` to optimize performance by preventing unnecessary re-renders. This ensures that the component only re-renders when the `content` prop changes.

3. **Rendering Markdown**:
   - The `Markdown` component is used to render the `content` prop as HTML. This allows the assistant's messages to include rich text formatting, such as bold, italics, links, and code blocks.
   - The `Markdown` component is passed the `html` prop to indicate that the content should be rendered as HTML.

4. **Styling and Layout**:
   - The component is wrapped in a `div` with the class `overflow-hidden w-full` to ensure that the content is displayed correctly within the chat interface. The `overflow-hidden` class prevents content overflow, and the `w-full` class ensures the component takes the full width of its container.

5. **JSX Structure**:
   - The component returns a JSX structure that includes the `Markdown` component wrapped in a `div`. This structure ensures that the content is rendered and styled appropriately within the chat interface.

By following these steps, the `AssistantMessage` component ensures that messages from the assistant are displayed with proper formatting and styling, leveraging the Markdown component to render rich text content as HTML.

### BaseChat.module.scss

@BaseChat.module.scss This file contains the styles for the BaseChat component, defining the layout and appearance of the chat interface. It includes styles for chat visibility, transitions, and the overall chat container.

#### How It Works

1. **Chat Visibility**:
   - The `.BaseChat` class uses the `data-chat-visible` attribute to control the visibility of the chat interface.
   - When `data-chat-visible` is set to `false`, the chat interface is hidden by applying specific styles to the `.Chat` class.
   - The `--workbench-inner-width` and `--workbench-left` CSS variables are set to adjust the layout when the chat is hidden.

2. **Transitions**:
   - The `.Chat` class defines transition properties for `transform` and `opacity` to create smooth animations when the chat visibility changes.
   - The `transition-duration` is set to `0.3s` to control the speed of the transition.
   - The `will-change` property is used to optimize the performance of the transition by informing the browser of the properties that will change.

3. **Chat Container**:
   - The `.Chat` class is styled with `opacity: 1` to ensure it is fully visible when the chat is not hidden.
   - The `transform: translateX(-50%)` style is applied to move the chat container off-screen when it is hidden, creating a sliding effect.

By following these steps, the `BaseChat.module.scss` file ensures that the chat interface is displayed with smooth transitions and can be toggled based on user interaction.

### BaseChat.tsx

@BaseChat.tsx This is the base component for the chat interface. It provides the foundational structure and behavior for the chat interface, including handling user input and managing the state of chat messages. The component integrates various sub-components, manages the chat state, handles user input, and triggers animations for a smooth user experience.

#### How It Works

1. **Component Initialization**:
   - The `BaseChat` component is a functional component that takes various props such as `textareaRef`, `messageRef`, `scrollRef`, `showChat`, `chatStarted`, `isStreaming`, `messages`, `input`, `sendMessage`, `handleInputChange`, `enhancePrompt`, and `handleStop`.
   - It uses `React.forwardRef` to forward a ref to the root `div` element of the component.

2. **State Management**:
   - The component manages the state of the chat interface, including whether the chat has started, if messages are streaming, and the current input value.

3. **Rendering Sub-Components**:
   - The `ClientOnly` component is used to render the `Menu` and `Workbench` components only on the client side.
   - The `Messages` component is conditionally rendered based on whether the chat has started. It displays the list of chat messages and handles the display of streaming messages.
   - The `SendButton` component is rendered within the chat input area and handles the click event to send messages.

4. **Handling User Input**:
   - The `textarea` element is used for user input. It handles the `onKeyDown` event to send messages when the Enter key is pressed, and the `onChange` event to update the input value.
   - The `enhancePrompt` function is called when the "Enhance prompt" button is clicked, enhancing the user's input prompt.

5. **Styling and Layout**:
   - The component uses the `classNames` utility to conditionally apply CSS classes based on the component's state.
   - The `styles.BaseChat` class is applied to the root `div` element to style the chat interface.
   - The `textarea` element is styled with a minimum and maximum height, and the `SendButton` component is conditionally displayed based on the input length and streaming state.

6. **Example Prompts**:
   - The component displays a list of example prompts when the chat has not started. These prompts can be clicked to send a predefined message.

By following these steps, the `BaseChat` component ensures that the chat interface is displayed with proper structure and behavior, handling user input and managing the state of chat messages efficiently.

### Chat.client.tsx

@Chat.client.tsx This is the main chat component that integrates various sub-components such as `BaseChat`, `ToastContainer`, and `ChatImpl`. It manages the overall state and interactions within the chat interface.

#### How It Works

1. **Component Initialization**:
   - The `Chat` component is a functional component that initializes the chat interface.
   - It imports various hooks and utilities such as `useStore`, `useChat`, `useAnimate`, and others to manage state, handle animations, and process messages.

2. **State Management**:
   - The component uses the `useState` hook to manage the state of the chat, including whether the chat has started (`chatStarted`) and the current input value (`input`).
   - The `useStore` hook is used to access the `chatStore` and `workbenchStore` for managing chat and workbench states.

3. **Message Handling**:
   - The `useChat` hook is used to manage chat messages, handle input changes, and send messages to the server.
   - The `parseMessages` function from `useMessageParser` is used to parse incoming messages and extract relevant data.

4. **Error Handling**:
   - The component handles errors using the `toast` library to display error notifications.
   - The `onError` callback in the `useChat` hook logs errors and displays a toast notification if a request fails.

5. **Animations**:
   - The `useAnimate` hook is used to handle animations for the chat interface.
   - The `runAnimation` function triggers animations when the chat starts, creating a smooth transition effect.

6. **User Input**:
   - The `textarea` element is used for user input, with event handlers for `onKeyDown` and `onChange` to manage input changes and send messages.
   - The `sendMessage` function processes the user input, saves any file modifications, and sends the message to the server.

7. **Toast Notifications**:
   - The `ToastContainer` component is used to display toast notifications for success and error messages.
   - Custom icons and close buttons are provided for the toast notifications to enhance the user experience.

8. **Rendering Sub-Components**:
   - The `ChatImpl` component is conditionally rendered based on the `ready` state from `useChatHistory`.
   - The `BaseChat` component is used to render the chat interface, passing various props such as `textareaRef`, `input`, `messages`, and event handlers.

By following these steps, the `Chat.client.tsx` component ensures that the chat interface is initialized, manages state and interactions, handles errors, and coordinates the display of toast notifications efficiently.

### CodeBlock.module.scss

@CodeBlock.module.scss This file contains the styles for the CodeBlock component, including the appearance of code blocks and the copy-to-clipboard feature. It defines the layout and styling for the code block container and the copy button.

#### How It Works

1. **Copy Button Styling**:
   - The `.CopyButtonContainer` class is used to style the container for the copy button.
   - The `button:before` pseudo-element is used to display the text "Copied" when the button is clicked.
   - The `content` property sets the text to 'Copied'.
   - The `font-size` property sets the font size to 12px.
   - The `position` property sets the position to `absolute` to position the text relative to the button.
   - The `left` property sets the horizontal position of the text to -53px.
   - The `padding` property adds padding around the text for better readability.
   - The `height` property sets the height of the text container to 30px.

By following these steps, the `CodeBlock.module.scss` file ensures that the code block component is styled correctly, with a visually appealing layout and a functional copy-to-clipboard feature.

### CodeBlock.tsx

@CodeBlock.tsx This component is responsible for rendering code blocks with syntax highlighting. It uses Shiki for syntax highlighting and provides a copy-to-clipboard feature. The component processes the code, applies syntax highlighting, and allows users to copy the code to the clipboard with a visual indication of the copy action.

#### How It Works

1. **Initialization**:
   - The `CodeBlock` component is initialized with props including `className`, `code`, `language`, `theme`, and `disableCopy`.
   - Default values are set for `language` (`plaintext`) and `theme` (`dark-plus`).

2. **State Management**:
   - The component uses the `useState` hook to manage the state of the HTML content (`html`) and the copy status (`copied`).

3. **Copy to Clipboard**:
   - The `copyToClipboard` function is defined to handle copying the code to the clipboard.
   - It checks if the code has already been copied to prevent multiple copies.
   - The function uses the `navigator.clipboard.writeText` method to copy the code.
   - The `copied` state is set to `true` and a timeout is set to reset it after 2 seconds.

4. **Effect Hook**:
   - The `useEffect` hook is used to process the code and apply syntax highlighting.
   - It checks if the provided language is supported by Shiki.
   - The `codeToHtml` function from Shiki is called asynchronously to convert the code to HTML with syntax highlighting.
   - The resulting HTML is stored in the `html` state.

5. **Rendering**:
   - The component returns a `div` element with a combination of class names for styling.
   - A nested `div` is used to display the copy button, which is conditionally rendered based on the `disableCopy` prop.
   - The copy button uses the `copied` state to show a visual indication when the code is copied.
   - The `dangerouslySetInnerHTML` attribute is used to render the processed HTML content.

By following these steps, the `CodeBlock.tsx` component ensures that code blocks are rendered with syntax highlighting and provides a user-friendly copy-to-clipboard feature with visual feedback.

### Markdown.module.scss

@Markdown.module.scss This file contains the styles for the Markdown component, defining the appearance of markdown content within chat messages. It includes styles for various markdown elements such as headings, paragraphs, code, blockquotes, lists, and tables.

#### How It Works

1. **General Styling**:
   - The `.MarkdownContent` class sets the line height and text color for the markdown content.
   - It ensures that all direct child elements, except the last one, have a margin at the bottom for spacing.

2. **Headings**:
   - The `:is(h1, h2, h3, h4, h5, h6)` selector applies styles to all heading levels.
   - The `not-inside-actions` mixin ensures that the styles are not applied inside elements with the `.actions` class.
   - Each heading level (`h1` to `h6`) has specific font sizes and additional styles like border-bottom for `h1` and `h2`.

3. **Paragraphs**:
   - The `p` selector ensures that paragraphs have pre-wrapped white space.
   - It also sets margins for paragraphs that are not the last of their type.

4. **Links**:
   - The `a` selector styles links with a specific color and removes the underline by default.
   - On hover, the underline is added back for better user interaction.

5. **Inline Code**:
   - The `:not(pre) > code` selector styles inline code elements with a monospace font and specific background and text colors.
   - The `not-inside-actions` mixin is used to apply additional styles like border-radius and padding.

6. **Code Blocks**:
   - The `pre` selector styles code blocks with padding and border-radius.
   - The `pre:has(> code)` selector ensures that code blocks have a monospace font and are scrollable horizontally.

7. **Blockquotes**:
   - The `blockquote` selector styles blockquotes with padding, a left border, and a specific text color.

8. **Lists**:
   - The `:is(ul, ol)` selector applies styles to unordered and ordered lists, ensuring proper padding and margins.
   - The `ul` and `ol` selectors set specific list styles (disc for unordered lists and decimal for ordered lists).
   - The `li` selector ensures that list items have proper spacing and margins.

9. **Images**:
   - The `img` selector ensures that images are responsive and fit within the container.

10. **Horizontal Rules**:
    - The `hr` selector styles horizontal rules with a specific height, margin, and background color.

11. **Tables**:
    - The `table` selector ensures that tables are collapsed and take the full width of the container.
    - The `:is(th, td)` selector applies padding and borders to table headers and cells.
    - The `tr:nth-child(2n)` selector styles alternate rows with a different background color for better readability.

By following these steps, the `Markdown.module.scss` file ensures that markdown content is styled consistently and is visually appealing within chat messages.

### Markdown.tsx

@Markdown.tsx This component is responsible for rendering markdown content within chat messages. It leverages the React Markdown library and integrates with various plugins to enhance markdown rendering. The component ensures that markdown content is displayed correctly with proper formatting and styling.

#### How It Works

1. **Initialization**:
   - The `Markdown` component is a memoized functional component that takes `children`, `html`, and `limitedMarkdown` as props.
   - The `children` prop contains the markdown content to be rendered.
   - The `html` prop determines whether HTML content is allowed within the markdown.
   - The `limitedMarkdown` prop specifies whether to limit the markdown features.

2. **Logger Setup**:
   - A scoped logger named `MarkdownComponent` is created using the `createScopedLogger` utility for logging purposes.

3. **Component Mapping**:
   - The `components` object is created using the `useMemo` hook to optimize performance.
   - It defines custom renderers for `div` and `pre` elements:
     - **div**: Checks if the class name includes `__boltArtifact__` and renders an `Artifact` component if true. Otherwise, it renders a standard `div`.
     - **pre**: Extracts the code block and its language from the `pre` element and renders a `CodeBlock` component.

4. **Markdown Rendering**:
   - The `ReactMarkdown` component is used to render the markdown content.
   - It is configured with the following props:
     - `allowedElements`: Specifies the allowed HTML elements.
     - `className`: Applies the `MarkdownContent` class for styling.
     - `components`: Uses the custom component mappings defined earlier.
     - `remarkPlugins`: Applies remark plugins based on the `limitedMarkdown` prop.
     - `rehypePlugins`: Applies rehype plugins based on the `html` prop.

By following these steps, the `Markdown` component ensures that markdown content is rendered efficiently and correctly within chat messages, with appropriate formatting and styling.

### Messages.client.tsx

@Messages.client.tsx This component is responsible for displaying a list of chat messages within the chat interface. It differentiates between user messages and assistant messages, applying appropriate styling and animations to each. The component also handles the display of streaming messages, ensuring a smooth user experience.

#### How It Works

1. **Component Initialization**:
   - The `Messages` component is a forward-ref functional component that takes `MessagesProps` as its props.
   - The props include `id`, `className`, `isStreaming`, and `messages`.

2. **Default Prop Values**:
   - The `isStreaming` prop defaults to `false` if not provided.
   - The `messages` prop defaults to an empty array if not provided.

3. **Rendering Messages**:
   - The component iterates through the `messages` array using the `map` function.
   - For each message, it extracts the `role` and `content` properties.
   - It determines if the message is a user message by checking if the `role` is `'user'`.
   - It also checks if the message is the first or last in the array to apply specific styles.

4. **Conditional Styling**:
   - The component uses the `classNames` utility to apply conditional styling based on the message type and position.
   - User messages and non-streaming messages (or streaming messages that are not the last) have a specific background color.
   - The last streaming message has a gradient background for a smooth transition effect.
   - The first message does not have a top margin, while subsequent messages do.

5. **User Message Rendering**:
   - If the message is a user message, it renders a user icon within a styled `div`.
   - The `UserMessage` component is used to render the content of the user message.

6. **Assistant Message Rendering**:
   - If the message is not a user message, the `AssistantMessage` component is used to render the content.

7. **Streaming Indicator**:
   - If `isStreaming` is `true`, a loading indicator is displayed at the bottom of the message list.
   - The loading indicator uses a specific class for styling and animation.

By following these steps, the `Messages` component ensures that chat messages are displayed correctly with appropriate styling and animations, providing a seamless user experience within the chat interface.

### SendButton.client.tsx

@SendButton.client.tsx This component represents the send button in the chat interface. It uses Framer Motion for animations and handles the click event to send messages. The component provides visual feedback for the send action and integrates with the chat input to trigger message sending.

#### How It Works

1. **Component Initialization**:
   - The `SendButton` component is a functional component that takes `SendButtonProps` as its props.
   - The props include `show`, `isStreaming`, and `onClick`.

2. **Default Prop Values**:
   - The `isStreaming` prop is optional and defaults to `false` if not provided.
   - The `onClick` prop is optional and can be a function that handles the click event.

3. **Framer Motion Integration**:
   - The component uses the `AnimatePresence` and `motion` components from Framer Motion for animations.
   - The `AnimatePresence` component ensures that the send button is animated when it appears or disappears.
   - The `motion.button` component is used to animate the button itself with specific properties for initial, animate, and exit states.

4. **Custom Easing Function**:
   - A custom easing function `customEasingFn` is defined using `cubicBezier` to control the animation timing.

5. **Conditional Rendering**:
   - The `SendButton` component conditionally renders the button based on the `show` prop.
   - If `show` is `true`, the button is rendered with animations; otherwise, it is not rendered.

6. **Button Click Handling**:
   - The `onClick` event handler is attached to the button.
   - When the button is clicked, the event is prevented from its default action, and the `onClick` prop function is called if it is provided.

7. **Button Content**:
   - The button content changes based on the `isStreaming` prop.
   - If `isStreaming` is `true`, a stop icon is displayed; otherwise, an arrow icon is displayed.

By following these steps, the `SendButton` component ensures that the send button is animated, provides visual feedback for the send action, and integrates with the chat input to trigger message sending efficiently.

### UserMessage.tsx

@UserMessage.tsx This component is responsible for rendering messages from the user in the chat interface. It ensures that user messages are displayed correctly with proper formatting and styling, while also removing any unwanted modifications from the content.

#### How It Works

1. **Component Initialization**:
   - The `UserMessage` component is a functional component that takes `UserMessageProps` as its props.
   - The props include `content`, which is the message content to be rendered.

2. **Sanitizing User Message**:
   - The `sanitizeUserMessage` function is used to sanitize the user message content.
   - This function removes any unwanted modifications from the content using a regular expression defined in `modificationsRegex`.
   - The sanitized content is then trimmed to remove any leading or trailing whitespace.

3. **Rendering the Message**:
   - The sanitized content is passed to the `Markdown` component for rendering.
   - The `Markdown` component is used with the `limitedMarkdown` prop to ensure that only a limited set of Markdown features are enabled.
   - The rendered Markdown content is wrapped in a `div` with specific styling classes to ensure proper display and overflow handling.

By following these steps, the `UserMessage` component ensures that user messages are displayed correctly with proper formatting and styling, while also removing any unwanted modifications from the content.
