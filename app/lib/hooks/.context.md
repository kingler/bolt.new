---
component: hooks
description: Contains custom hooks for various functionalities within the application
main-technologies:
  - TypeScript
  - React
  - Web APIs
conventions:
  - Use memoization for performance optimization
  - Use appropriate Web APIs for specific functionalities
  - Ensure hooks are reusable and maintainable
---

# Custom Hooks

This directory contains custom hooks that provide various functionalities within the application. These hooks encapsulate logic for handling specific tasks, making the code more modular and reusable.

## Structure

- `index.ts`: Entry point for exporting all hooks
- `useMessageParser.ts`: Hook for parsing messages
- `usePromptEnhancer.ts`: Hook for enhancing prompts
- `useShortcuts.ts`: Hook for handling keyboard shortcuts
- `useSnapScroll.ts`: Hook for managing snap scrolling

## Key Responsibilities

1. Encapsulating logic for specific functionalities within hooks
2. Ensuring hooks are reusable and maintainable
3. Providing a clean and modular approach to handling complex logic
4. Enhancing performance through memoization and efficient state management

## Development Guidelines

- Use memoization (React.memo) for performance optimization
- Utilize appropriate Web APIs for specific functionalities
- Ensure hooks are reusable and maintainable
- Use type hints and docstrings for better code readability

## Component Implementation

### index.ts

This file serves as the entry point for exporting all hooks within the directory. It ensures that all hooks are easily accessible from a single import statement.

### useMessageParser.ts

This hook is responsible for parsing messages. It uses the `StreamingMessageParser` class to handle the parsing logic and manages the state of parsed messages.

#### Purpose
The purpose of this hook is to parse messages and manage the state of parsed content, enabling the application to handle message parsing in a modular and reusable manner.

#### How It Works

1. **State Management**:
   - The hook uses the `useState` hook to manage the state of parsed messages.

2. **Message Parsing**:
   - The `parseMessages` function is defined using the `useCallback` hook to ensure it is memoized.
   - The function iterates over the messages and uses the `StreamingMessageParser` instance to parse the content of assistant messages.
   - The parsed content is then stored in the state.

3. **Callbacks**:
   - The `StreamingMessageParser` is configured with callbacks for handling various actions such as opening and closing artifacts and actions.

By following these steps, the `useMessageParser` hook ensures that messages are parsed efficiently and the state is managed appropriately.

### usePromptEnhancer.ts

This hook is responsible for enhancing prompts. It manages the state of the enhancement process and provides functions to enhance and reset prompts.

#### Purpose
The purpose of this hook is to enhance prompts by sending them to an API and updating the state based on the response, enabling the application to handle prompt enhancement in a modular and reusable manner.

#### How It Works

1. **State Management**:
   - The hook uses the `useState` hook to manage the state of the enhancement process, including whether the prompt is being enhanced and whether it has been enhanced.

2. **Enhancing Prompts**:
   - The `enhancePrompt` function is defined as an asynchronous function that sends the input prompt to an API endpoint.
   - The function reads the response stream and updates the input prompt in real-time.
   - The state is updated to reflect the progress and completion of the enhancement process.

3. **Resetting Enhancer**:
   - The `resetEnhancer` function resets the state of the enhancement process.

By following these steps, the `usePromptEnhancer` hook ensures that prompts are enhanced efficiently and the state is managed appropriately.

### useShortcuts.ts

This hook is responsible for handling keyboard shortcuts. It listens for keydown events and triggers the corresponding actions based on the defined shortcuts.

#### Purpose
The purpose of this hook is to handle keyboard shortcuts, enabling the application to respond to user input in a modular and reusable manner.

#### How It Works

1. **Shortcut Event Emitter**:
   - The `ShortcutEventEmitter` class is defined to manage the dispatching and handling of shortcut events.

2. **Listening for Keydown Events**:
   - The `useEffect` hook is used to add an event listener for keydown events.
   - The `handleKeyDown` function checks if the pressed key combination matches any of the defined shortcuts and triggers the corresponding action.

3. **Cleanup**:
   - The event listener is removed when the component is unmounted to prevent memory leaks.

By following these steps, the `useShortcuts` hook ensures that keyboard shortcuts are handled efficiently and the state is managed appropriately.

### useSnapScroll.ts

This hook is responsible for managing snap scrolling. It ensures that the scroll position is automatically adjusted based on the content size.

#### Purpose
The purpose of this hook is to manage snap scrolling, enabling the application to handle scroll position adjustments in a modular and reusable manner.

#### How It Works

1. **Refs for Scroll Management**:
   - The hook uses the `useRef` hook to create references for managing the scroll state and elements.

2. **Observing Content Size**:
   - The `messageRef` function is defined using the `useCallback` hook to observe the size of the content using the `ResizeObserver` API.
   - The scroll position is adjusted automatically when the content size changes.

3. **Handling Scroll Events**:
   - The `scrollRef` function is defined using the `useCallback` hook to add an event listener for scroll events.
   - The scroll state is updated based on the scroll position.

4. **Cleanup**:
   - The observers and event listeners are disconnected and removed when the component is unmounted to prevent memory leaks.

By following these steps, the `useSnapScroll` hook ensures that snap scrolling is managed efficiently and the state is updated appropriately.
