---
component: runtime_components
description: Contains runtime components and utilities for the application
main-technologies:
  - TypeScript
  - Node.js
  - WebContainer API
  - Vitest
conventions:
  - Use TypeScript for type safety and better code readability
  - Use WebContainer API for running actions in a web-based container
  - Use Vitest for testing
---

# Runtime Components

This directory contains runtime components and utilities for the application. These components define the structure and behavior of various runtime operations, enabling efficient and reliable execution of actions and message parsing.

## Structure

- `action-runner.ts`: Component for running actions within a web-based container
- `message-parser.ts`: Component for parsing messages and extracting artifacts and actions
- `message-parser.spec.ts`: Test suite for the message parser component

## Key Responsibilities

1. Running actions within a web-based container
2. Parsing messages to extract artifacts and actions
3. Testing the message parser component for correctness

## Development Guidelines

- Use TypeScript for type safety and better code readability
- Utilize WebContainer API for running actions in a web-based container
- Implement tests using Vitest
- Use type hints and docstrings for better code readability

## Component Implementation

### action-runner.ts

This component is responsible for running actions within a web-based container. It uses the WebContainer API to execute shell commands and manage file operations.

#### Purpose

The purpose of this component is to manage and execute actions defined in the application. It handles different types of actions, such as shell commands and file operations, and ensures they are executed within a web-based container.

#### How It Works

1. The `ActionRunner` class is initialized with a promise that resolves to a `WebContainer` instance.
2. Actions are added using the `addAction` method, which stores the action's state and sets up an abort controller.
3. The `runAction` method is used to execute the action. It updates the action's state and calls the appropriate method based on the action type.
4. The `#executeAction` method handles the execution of the action and updates its state based on the result.
5. The `#runShellAction` method executes shell commands within the web container and handles process termination.
6. The `#runFileAction` method manages file operations, such as creating directories and writing files within the web container.
7. The `#updateAction` method updates the state of an action in the actions map.

### message-parser.ts

This component is responsible for parsing messages and extracting artifacts and actions. It processes the input message, identifies artifacts and actions, and triggers the appropriate callbacks.

#### Purpose

The purpose of this component is to parse incoming messages, extract artifacts and actions, and trigger callbacks for further processing. It ensures that the message content is correctly interpreted and relevant data is extracted.

#### How It Works

1. **StreamingMessageParser Class**:
   - The `StreamingMessageParser` class is initialized with optional callbacks and an artifact element factory.

2. **parse Method**:
   - The `parse` method processes the input message, identifies artifacts and actions, and triggers the appropriate callbacks.
   - It maintains the state of the message, including the current position, whether it is inside an artifact or action, and the current artifact and action data.
   - The method iterates through the input message, identifying and processing artifact and action tags.
   - When an artifact or action tag is encountered, the method extracts the relevant attributes and triggers the corresponding callbacks.

3. **reset Method**:
   - The `reset` method clears the internal state of the message parser, removing all stored messages.

4. **#parseActionTag Method**:
   - The `#parseActionTag` method extracts attributes from an action tag and returns the action data.
   - It identifies the type of action (e.g., file, shell) and extracts relevant attributes such as file path for file actions.

5. **#extractAttribute Method**:
   - The `#extractAttribute` method extracts a specific attribute from a tag string.
   - It uses a regular expression to match and retrieve the attribute value from the tag.

6. **createArtifactElement Function**:
   - The `createArtifactElement` function generates an HTML element for an artifact.
   - It constructs the element with appropriate attributes and returns it as a string.

7. **camelToDashCase Function**:
   - The `camelToDashCase` function converts camelCase strings to dash-case.
   - It is used to format attribute names for HTML elements.

By following these steps, the `StreamingMessageParser` ensures that messages are parsed efficiently, artifacts and actions are correctly identified, and the appropriate callbacks are triggered for further processing.

#### Purpose

The purpose of this component is to parse incoming messages, extract artifacts and actions, and trigger callbacks for further processing. It ensures that the message content is correctly interpreted and relevant data is extracted.

#### How It Works

1. The `StreamingMessageParser` class is initialized with optional callbacks and an artifact element factory.
2. The `parse` method processes the input message, identifies artifacts and actions, and triggers the appropriate callbacks.
3. The method maintains the state of the message, including the current position, whether it is inside an artifact or action, and the current artifact and action data.
4. The method iterates through the input message, identifying and processing artifact and action tags.
5. When an artifact or action tag is encountered, the method extracts the relevant attributes and triggers the corresponding callbacks.
6. The `#parseActionTag` method extracts attributes from an action tag and returns the action data.
7. The `#extractAttribute` method extracts a specific attribute from a tag string.

### message-parser.spec.ts

This file contains the test suite for the message parser component. It uses Vitest to define and run tests, ensuring the correctness of the message parser implementation.

#### Purpose

The purpose of this file is to test the message parser component and ensure it correctly parses messages, extracts artifacts and actions, and triggers the appropriate callbacks.

#### How It Works

1. The test suite is defined using Vitest's `describe`, `it`, and `expect` functions.
2. Various test cases are defined to cover different scenarios, such as normal text, HTML tags, invalid artifacts, and valid artifacts with and without actions.
3. The `runTest` function is used to run each test case, initializing the message parser, processing the input message, and verifying the output and callback invocations.
4. The test cases ensure that the message parser correctly handles different input scenarios and triggers the appropriate callbacks.

## Usage Example
